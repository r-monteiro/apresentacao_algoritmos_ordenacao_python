# -*- coding: utf-8 -*-
"""Trabalho_ana_alg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vDzREiXQ7NV2MrQpeSe8snxn-tNLgq2a

#**ALGORITMOS DE ORDENAÇÃO**
#**MERGE SORT, QUICK SORT, SHELL SORT**
#---------------------
#Anna Aló
#João Vitor Barbieri
#Mateus Natan R. Salgueiro
#Paulo Elias T. Generozo
#Paulo Henrique R. Gonçalves
#Rafael A. M. Monteiro
#Thomas Jefferson Américo
#Willian Naloto
#---------------------

#**MERGE SORT**
"""

def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    #Divide a lista ao meio
    meio = len(arr) // 2
    metade_esquerda = arr[:meio]
    metade_direita = arr[meio:]

    #Recursivamente ordena as duas metades
    metade_esquerda = merge_sort(metade_esquerda)
    metade_direita = merge_sort(metade_direita)

    #Combina as duas metades ordenadas
    return merge(metade_esquerda, metade_direita)

def merge(esquerda, direita):
    resultado = []
    idx_esquerda, idx_direita = 0, 0

    #Combina os elementos de ambas as listas ordenadas
    while idx_esquerda < len(esquerda) and idx_direita < len(direita):
        if esquerda[idx_esquerda] < direita[idx_direita]:
            resultado.append(esquerda[idx_esquerda])
            idx_esquerda += 1
        else:
            resultado.append(direita[idx_direita])
            idx_direita += 1

    #Adiciona os elementos restantes de esquerda (se houver)
    while idx_esquerda < len(esquerda):
        resultado.append(esquerda[idx_esquerda])
        idx_esquerda += 1

    #Adiciona os elementos restantes de direita (se houver)
    while idx_direita < len(direita):
        resultado.append(direita[idx_direita])
        idx_direita += 1

    return resultado

#Input de valores
valores = input("Insira os valores separados por espaço: ").split()
#Convertendo os valores para inteiros
arr = [int(valor) for valor in valores]

print("Array original:", arr)
arr_ordenado = merge_sort(arr)
print("Array ordenado:", arr_ordenado)

"""#QUICK SORT"""

def quick_sort(arr):
    #Caso base: se a lista tiver tamanho 0 ou 1, retorna a lista como está
    if len(arr) <= 1:
        return arr

    #Escolha do pivô: no exemplo, o pivô é o elemento do meio da lista
    pivot = arr[len(arr) // 2]

    #Divide a lista em três partes: elementos menores que o pivô, iguais ao pivô e maiores que o pivô
    left = [x for x in arr if x < pivot]
    middle = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]

    #Concatena recursivamente as listas ordenadas à esquerda, ao redor do pivô e à direita
    return quick_sort(left) + middle + quick_sort(right)

#Input de valores
valores = input("Insira os valores separados por espaço: ").split()
#Convertendo os valores para inteiros
arr = [int(valor) for valor in valores]

print("Array original:", arr)
arr_ordenado = quick_sort(arr)
print("Array ordenado:", arr_ordenado)

"""#SHELL SORT"""

def shell_sort(arr):
    n = len(arr)
    #Começa com uma lacuna grande e a reduz gradualmente
    gap = n // 2

    while gap > 0:
        #Percorre os elementos da lista a partir da lacuna atual
        for i in range(gap, n):
            #Salva o valor atual para ser comparado posteriormente
            valor_atual = arr[i]
            #Move os elementos anteriores ao valor atual, que são maiores que ele, para a frente
            j = i
            while j >= gap and arr[j - gap] > valor_atual:
                arr[j] = arr[j - gap]
                j -= gap
            #Insere o valor atual na posição correta
            arr[j] = valor_atual
        #Reduz a lacuna para a próxima iteração
        gap //= 2

#Input de valores
valores = input("Insira os valores separados por espaço: ").split()
#Convertendo os valores para inteiros
arr = [int(valor) for valor in valores]

print("Array original:", arr)
shell_sort(arr)
print("Array ordenado:", arr)